package model
import java.io.File
object Programme {
  val programs = List("BCS", "BSE", "BIS", "BCNS", "BIT", "BMCE", "BSBA", "BSDA")

  val bcsFiles = Map(
    2016 -> List("/data/bcs/481BCS-2016.xls"),
    2017 -> List("/data/bcs/481BCS-2017.xls"),
    2018 -> List("/data/bcs/481BCS-2018.xls"),
    2019 -> List("/data/bcs/481BCS-2019.xls", "/data/bcs/481BCS-2019(CGPA).xls"),
    2020 -> List("/data/bcs/481BCS_CGPA-2020.xls", "/data/bcs/481BCS CAVG-2020.xls"),
    2021 -> List("/data/bcs/481BCS_CGPA-2021.xls", "/data/bcs/481BCS CAVG-2021.xls"),
    2022 -> List("/data/bcs/481BCS_CGPA-2022.xls", "/data/bcs/481BCS_CAVG-2022.xls"),
    2023 -> List("/data/bcs/481BCS_RESULT_BROADSHEET_CAVG_2023.xls", "/data/bcs/481BCS_RESULT_BROADSHEET_CGPA_2023.xls", "/data/bcs/BCS1_RESULT_BROADSHEET_CGPA_2023.xls")
  )
  val bseFiles = Map(
    2017 -> List("/data/bse/481BSE-2017.xls"),
    2018 -> List("/data/bse/481BSE-2018.xls"),
    2019 -> List("/data/bse/481BSE-2019.xls", "/data/bse/481BSE-2019-gpa.xls"),
    2020 -> List("/data/bse/481BSE-CGPA-2020.xls", "/data/bse/481BSE-non-GPA-2020.xls"),
    2021 -> List("/data/bse/481BSE-CGPA-2021.xls","/data/bse/481BSE-non-GPA-2021.xls"),
    2022 -> List("/data/bse/481BSE_CGPA-2022.xls","/data/bse/481BSE_CAVG-2022.xls"),
    2023 -> List("/data/bse/BSE_RESULT_BROADSHEET_CAVG_2023.xls","/data/bse/BSE_RESULT_BROADSHEET_CGPA_2023.xls", "/data/bse/BSE1_RESULT_BROADSHEET_CGPA_2023.xls")
  )
  val bisFiles = Map(
    2017 -> List("/data/bis/481BIS-2017.xls"),
    2018 -> List("/data/bis/481BIS-2018.xls"),
    2019 -> List("/data/bis/481BIS-2019.xls", "/data/bis/481BIS-2019-cgpa.xls"),
    2020 -> List("/data/bis/481BIS_CAVG-2020.xls", "/data/bis/481BIS_CGPA-2020.xls"),
    2021 -> List("/data/bis/481BIS-2021-cavg.xls","/data/bis/481BIS-2021-cgpa.xls"),
    2022 -> List("/data/bis/481BIS-2022-CAVG.xls", "/data/bis/481BIS-2022-CGPA.xls")
  )
  val bcnsFiles = Map(
    2017 -> List("/data/bcns/481BCNS after scaling NET2102-2017.xls"),
    2018 -> List("/data/bcns/481BCNS2018.xls"),
    2019 -> List("/data/bcns/BCNS-2019.xls", "/data/bcns/BCNS-2019-gpa.xls"),
    2020 -> List("/data/bcns/481BCNS_CAVG-2020.xls", "/data/bcns/481BCNS_CGPA-2020.xls"),
    2021 -> List("/data/bcns/481BCNS_CAVG-2021.xls","/data/bcns/481BCNS_CGPA-2021.xls"),
    2022 -> List("/data/bcns/481BCNS_CAVG-2022.xls","/data/bcns/481BCNS_CGPA-2022.xls"),
    2023 -> List("/data/bcns/BCNS_RESULT_BROADSHEET_CAVG_2023.xls","/data/bcns/BCNS_RESULT_BROADSHEET_CGPA_2023.xls","/data/bcns/BCNS1_RESULT_BROADSHEET_CGPA_2023.xls")
  )
  val bitFiles = Map(
    2017 -> List("/data/bit/481BIT after scaling NET2102-2017.xls"),
    2018 -> List("/data/bit/481BIT-2018.xls"),
    2019 -> List("/data/bit/481BIT-2019.xls", "/data/bit/481BIT-2019-GPA.xls"),
    2020 -> List("/data/bit/481BIT_CAVG-2020.xls", "/data/bit/481BIT_CGPA-2020.xls"),
    2021 -> List("/data/bit/481BIT_CAVG-2021.xls", "/data/bit/481BIT_CGPA-2021.xls"),
    2022 -> List("/data/bit/481BIT-2022_CAVG.xls", "/data/bit/481BIT-2022_CGPA.xls"),
    2023 -> List("/data/bit/BIT_RESULT_BROADSHEET_CAVG-2023.xls", "/data/bit/BIT_RESULT_BROADSHEET_CGPA-2023.xls", "/data/bit/BIT1_RESULT_BROADSHEET_CGPA-2023.xls")
  )
  val bmceFiles = Map(
    2017 -> List("/data/bmce/482BMCE-2017.xls"),
    2018 -> List("/data/bmce/482BMCE-2018.xls"),
    2019 -> List("/data/bmce/482BMCE-2019.xls", "/data/bmce/482BMCE-2019-gpa.xls"),
    2020 -> List("/data/bmce/482BMCE non GPA-2020.xls", "/data/bmce/482BMCE CGPA-2020.xls"),
    2021 -> List("/data/bmce/482BMCE non GPA-2021.xls", "/data/bmce/482BMCE CGPA-2021.xls"),
    2022 -> List("/data/bmce/482BMCE-2022_CAVG.xls", "/data/bmce/482BMCE-2022_CGPA.xls")
  )
  val bsbaFiles = Map(
    2017 -> List("/data/bsba/482BSBA-2017.xls"),
    2018 -> List("/data/bsba/482BSBA-2018.xls"),
    2019 -> List("/data/bsba/482BSBA-2019.xls", "/data/bsba/482BSBA-2019-gpa.xls"),
    2020 -> List("/data/bsba/482BSBA_CAVG-2020.xls", "/data/bsba/482BSBA_CGPA-2020.xls"),
    2021 -> List("/data/bsba/482BSBA_CAVG-2021.xls", "/data/bsba/482BSBA_CGPA-2021.xls"),
    2022 -> List("/data/bsba/482BSBA_CAVG-2022.xls", "/data/bsba/482BSBA_CGPA-2022.xls"),
    2023 -> List("/data/bsba/BSBA_RESULT_BROADSHEET_CAVG_2023.xls", "/data/bsba/BSBA_RESULT_BROADSHEET_CGPA_2023.xls")
  )
  val bsdaFiles = Map(
    2020 -> List("/data/bsda/482BSDA-2020.xls"),
    2021 -> List("/data/bsda/482BSDA-2021.xls"),
    2022 -> List("/data/bsda/482BSDA_CGPA-2022.xls"),
    2023 -> List("/data/bsda/BSDA_RESULT_BROADSHEET_CGPA_2023.xls", "/data/bsda/BSDA1_RESULT_BROADSHEET_CGPA_2023.xls","/data/bsda/BSDA_RESULT_BROADSHEET_CHEAH GYNN YIP_APR-JUL 2023.xls","/data/bsda/BSDA_RESULT_BROADSHEET_CHEE MING ZHENG_APR-JUL 2023.xls","/data/bsda/BSDA_RESULT_BROADSHEET_LAI YANN CHEANG_APR-JUL 2023.xls")
  )
  val qualificationFiles = Map(
    "BSE" -> "/data/bse/BSEQualification.xlsx",
    "BCS" -> "/data/bcs/BCSQualification.xlsx",
    "BIS" -> "/data/bis/BISQualification.xlsx",
    "BCNS" -> "/data/bcns/BCNSQualification.xlsx",
    "BIT" -> "/data/bit/BITQualification.xlsx",
    "BMCE" -> "/data/bmce/BMCEQualification.xlsx",
    "BSBA" -> "/data/bsba/BSBAQualification.xlsx",
    "BSDA" -> "/data/bsda/BSDAQualification.xlsx"
  )
  val enrolmentFiles = Map(
    "BSE" -> "/data/bse/BSEEnrollement.xls",
    "BCS" -> "/data/bcs/BCSEnrollment.xls",
    "BIS" -> "/data/bis/BISEnrollment.xls",
    "BCNS" -> "/data/bcns/BCNSEnrollment.xls",
    "BIT" -> "/data/bit/BITEnrollment.xls",
    "BMCE" -> "/data/bmce/BMCEEnrollment.xls",
    "BSBA" -> "/data/bsba/BSBAEnrollment.xls",
    "BSDA" -> "/data/bsda/BSDAEnrollment.xls",
  )
  val programFiles = Map("BCS" -> bcsFiles, "BSE" -> bseFiles, "BIS" -> bisFiles, "BCNS" -> bcnsFiles,
    "BIT" -> bitFiles, "BMCE"  ->  bmceFiles, "BSBA" -> bsbaFiles, "BSDA" -> bsdaFiles)
}

package Data

import scala.util.Try

case class Percentage(val value: Double)
case class ExamPeriod(year: Int, month: Int)

case class ModuleDesc(name: String, code: String) {
  override def equals(obj: Any): Boolean = {
    if (obj.isInstanceOf[ModuleDesc] ) 
      obj.asInstanceOf[ModuleDesc].code.replaceAll("\\s", "").toLowerCase() == code.replaceAll("\\s", "").toLowerCase()
    else
      false
  }
  override def hashCode(): Int = {
    code.replaceAll("\\s", "").toLowerCase().hashCode()
  }
  def year: Int = {
    var count = 0

    val code1 = code.replaceAll("\\s", "")
    while(Try(code1.charAt(count).toString.toInt).isFailure && count < 20) {
      count += 1
    }
    if (count < 20)
      code1.charAt(count).toString.toInt
    else
      1
  }
}


case class Module(description: ModuleDesc, period: ExamPeriod, courseworkPercentage: Option[Double], examPercentage: Option[Double], overallPercentage: Option[Double], grade: String, status: String){

  def year: Int = {
    var count = 0

    val code = description.code.replaceAll("\\s", "")
    while(Try(code.charAt(count).toString.toInt).isFailure && count < 20) {
      count += 1
    }
    if (count < 20)
      code.charAt(count).toString.toInt
    else
      1
  }
  def isPass: Boolean = {
    grade match {
      case "A^" => true
      case "A+^" => true
      case "A-^" => true
      case "A+" => true
      case "A-" => true
      case "A" => true
      case "B^" => true
      case "B+^" => true
      case "B-^" => true
      case "B" => true
      case "B+" => true
      case "B-" => true
      case "C" => true
      case "C+" => true
      case "C-" => true
      case "C^" => true
      case "C+^" => true
      case "C-^" => true
      case "D" => true
      case "D^" => true
      case "D*" => true
      case "D**" => true
      case "P" => true
      case "P*"=> true
      case "EX"=> true
      case "-" => true
      case "AU" => true
      case _ => false
    }
  }

  def isFail: Boolean = {
    grade match {
      case "F#^" => true
      case "F*" => true
      case "F" => true
      case _ => false
    }
  }
  def isFirst: Boolean = {
    status == "" || status == " "
  }
  def isFirstPass: Boolean = {
    grade match {
      case "A" => true
      case "A+" => true
      case "A-" => true
      case "B" => true
      case "B+" => true
      case "B-" => true
      case "C" => true
      case "C+" => true
      case "C-" => true
      case "D" => true
      case "D*" => false
      case "D**" => false
      case "P" => true
      case "P*"=> false
      case "EX"=> false
      case _ => false
    }
  }
  def isResitPass: Boolean = {
    grade match {
      case "A" => true
      case "A+" => true
      case "A-" => true
      case "B" => true
      case "B+" => true
      case "B-" => true
      case "C" => true
      case "C+" => true
      case "C-" => true
      case "C*" => true
      case "D" => false
      case "D*" => true
      case "D*^" => true
      case "D**" => true
      case "D**^" => true
      case "P" => false
      case "P*"=> false
      case "EX"=> false
      case _ => false
    }
  }
  def isExempted: Boolean = {
    grade match {
      case "EX"=> true
      case _ => false
    }
  }
  def isTransfer: Boolean = {
    grade match {
      case "A+^" => true
      case "A^" => true
      case "A-^" => true
      case "B+^" => true
      case "B^" => true
      case "B-^" => true
      case "C+^" => true
      case "C^" => true
      case "C-^" => true
      case "D^" => true
      case "F^" => true
      case "F#^" => true
      case _=> false
    }
  }
}

object Module {
  implicit class GradePointAverage(x: Double) {
    def toYearOneAverage: Double = x / 4.0 * 100
    def toGPA: Double = x / 100 * 4.00
  }

}

/**
  * Model class of student
  *
  * @param id
  * @param yearOneAverage
  * @param overallAverage CGPA of student start to calculate from second year
  * @param qualification
  * @param cohort
  * @param own
  * @param foreign
  * @param country
  * @param gender
  * @param name
  */
case class Student(val id: Int, val yearOneAverage: Percentage, val overallAverage: Option[Percentage], val qualification: Iterable[(String, String, String)], val cohort: String, val own: Boolean, val foreign: Boolean, val country: String,
                   val gender: String, val name: String, val isDiploma: Boolean, val isBachelor: Boolean, val isDirectEntry: Boolean) {
  val DPattern = "DIPLOMA".r
  val BPattern = "BACHELOR".r

  def highestQualification: String = {
    var high = ""
    var found = false
    for (q <- qualification){
      if (isBachelor && !found) {
        high = q._1
        found = true
      }  else if(isDiploma && !found){
        high = q._1
        found = true
      } else if(!found){
        high = q._1
      } else{

      }

    }
    high
  }

  def higestQualificationData: String = {
    var high = ""
    var data = ""
    var found = false
    for (q <- qualification){
      if (isBachelor && !found) {
        high = q._1
        data = q._2 + ", " + q._3
        found = true
      }  else if(isDiploma && !found){
        high = q._1
        data = q._2 + ", " + q._3
        found = true
      } else if(!found){
        high = q._1
        data = q._2 + ", " + q._3
      } else{

      }
    }
    data
  }

}


trait StudentResult { student: Student =>
  import scala.math._
  import breeze.stats._
  val result: Iterable[Module]

  def modules(minyear: Option[Int], month: Option[Int], code: Option[String], description: Option[String]): Seq[Module] = {
    var modulesTemp: Seq[Module] = Seq[Module]()
    minyear match {
      case Some(x) =>
        modulesTemp = student.result.filter(m => m.period.year == x ).toSeq
      case None =>
        modulesTemp = student.result.toSeq

    }
    month match {
      case Some(x) =>
        modulesTemp = modulesTemp.filter(m => m.period.month == x).toSeq
      case None =>
        modulesTemp = modulesTemp
    }
    code match {
      case Some(x)=>
        modulesTemp = modulesTemp.filter(m => m.description.code == x && m.description.name == description.get).toSeq
      case None =>
        modulesTemp = modulesTemp
    }
    modulesTemp
  }

  def firstPassMean(year: Option[Int], month: Option[Int]): Double = {
    var modules: Iterable[Module] = List[Module]()
    year match {
      case Some(x) =>
        modules = student.result.filter(m => m.period.year == x && m.status == "" && m.isFirstPass).toList
        mean(modules.filter(_.overallPercentage.isDefined).map(_.overallPercentage.get).toSeq)
      case None =>
        modules = student.result.toList
        mean(modules.filter(_.overallPercentage.isDefined).map(_.overallPercentage.get).toSeq)
    }
    month match {
      case Some(x) =>
        modules = modules.filter(m => m.period.month == x && m.status == "" && m.isFirstPass).toList
        mean(modules.filter(_.overallPercentage.isDefined).map(_.overallPercentage.get).toSeq)
      case None =>
        modules = modules
        mean(modules.filter(_.overallPercentage.isDefined).map(_.overallPercentage.get).toSeq)
    }

    //!modules.exists(x=> !x.isPass)
  }
  def averageMean(year: Option[Int], month: Option[Int]): Double = {
    var modules: Iterable[Module] = List[Module]()

    year match {
      case Some(x) =>
        modules = student.result.filter(m => m.period.year == x).toList.filter(m => !m.isExempted)
        mean(modules.filter(_.overallPercentage.isDefined).map(_.overallPercentage.get).toSeq)
      case None =>
        modules = student.result.toList.filter(m => !m.isExempted)
        mean(modules.filter(_.overallPercentage.isDefined).map(_.overallPercentage.get).toSeq)
    }
    month match {
      case Some(x) =>
        modules = modules.filter(m => m.period.month == x).toList
        mean(modules.filter(_.overallPercentage.isDefined).map(_.overallPercentage.get).toSeq)
      case None =>
        modules = modules
        mean(modules.filter(_.overallPercentage.isDefined).map(_.overallPercentage.get).toSeq)
    }

    //!modules.exists(x=> !x.isPass)
  }
  def averageMean(year: Option[Int], month: Option[Int], myear: Int): Option[Double] = {
    var modules: Iterable[Module] = List[Module]()
    year match {
      case Some(x) =>
        modules = student.result.filter(m => m.period.year == x && m.year == myear).toList.filter(m => !m.isExempted)
        if (modules.size == 0){
          None
        } else {
          Some(mean(modules.filter(_.overallPercentage.isDefined).map(_.overallPercentage.get).toSeq))
        }
      case None =>
        modules = student.result.toList.filter( m => !m.isExempted && m.year == myear)

        if (modules.size == 0){
          None
        } else {
          Some(mean(modules.filter(_.overallPercentage.isDefined).map(_.overallPercentage.get).toSeq))
        }
    }
    month match {
      case Some(x) =>
        modules = modules.filter(m => m.period.month == x).toList
        if (modules.size == 0){
          None
        } else {
          Some(mean(modules.filter(_.overallPercentage.isDefined).map(_.overallPercentage.get).toSeq))
        }
      case None =>
        modules = modules
        if (modules.size == 0){
          None
        } else {
          Some(mean(modules.filter(_.overallPercentage.isDefined).map(_.overallPercentage.get).toSeq))
        }
    }

    //!modules.exists(x=> !x.isPass)
  }

  def passAllSubject(year: Option[Int], month: Option[Int]): Option[Boolean] = {
    var modules: Iterable[Module] = List[Module]()
    year match {
      case Some(x) =>
        modules = student.result.filter(m => m.period.year == x).toList
      case None =>
        modules = student.result.toList
    }
    month match {
      case Some(x) =>
        modules = modules.filter(m => m.period.month == x).toList
      case None =>
        modules = modules
    }
    var found = true
    for ( m <- modules){
      if (!m.isPass){
        found = false
      }
    }
    if (modules.size == 0){
      None
    } else {
      Some(found)
    }
    //!modules.exists(x=> !x.isPass)
  }

  def inSemester(year: Option[Int], month: Option[Int]): Boolean = {
    var result = false
    year match {
      case Some(x) =>
        month match {
          case Some(y)=>
            result = student.result.exists(m => m.period.year == x && m.period.month == y)
          case None =>
            result = student.result.exists(m => m.period.year == x)
        }

      case None =>
        month match {
          case Some(y)=>
            result = student.result.exists(m => m.period.month == y)
          case None =>
            result = false
        }
    }
    result
  }
}


case class StudentStatus(id: String, cohort: String, sem: Int, name: String, status: String, graduated: String, classfication: String, cavg: Double, year: Int, country: String) {
  def isFinish: Boolean = {
    if (status == "Finished") {
      return true
    } else {
      false
    }
  }
  def isActive: Boolean = {
    if (status == "Finished" || status == "Active") {
      return true
    } else {
      false
    }
  }
  def isLeave: Boolean = {
    if ((status.contains("Withdraw") || status.contains("Transfer Out")) || status.contains("Excluded")) {
      return true
    } else {
      false
    }
  }
  def isTransfer: Boolean = {
    if (status.contains("Transfer Out")) {
      return true
    } else {
      false
    }
  }
  def isDefer: Boolean = {
    if (status.contains("Defer")) {
      return true
    } else {
      false
    }
  }
  def isWithDraw: Boolean = {
    if (status.contains("Withdraw")) {
      return true
    } else {
      false
    }
  }
  def isCompleted: Boolean = {
    if (status.contains("Completed")) {
      return true
    } else {
      false
    }
  }
  def isNotEnrol: Boolean = {
    if (status.contains("Not Enrol")) {
      return true
    } else {
      false
    }
  }
  def isGraduated: Boolean = {
    if (graduated.contains("Y") ) {
      return true
    } else {
      false
    }
  }
  def isExitProgram: Boolean = {
    if (status.contains("Excluded")) {
      return true
    } else {
      false
    }
  }

  def isOther: Boolean = {
    val list = List("Completed", "Withdraw", "Defer", "Transfer Out", "Finished" , "Excluded", "Not Enrol")
    if (list.contains(status)){
      false
    } else {
      true
    }
  }
  def isAttrition: Boolean = {
    val list = List("Withdraw", "Defer", "Transfer Out", "Excluded")
    if (list.contains(status)){
      false
    } else {
      true
    }
  }
}

case class StudentQualificationData( qualifications: Iterable[(String, String, String)], school: String, country: String, gender: String, race: String, ic: String)
