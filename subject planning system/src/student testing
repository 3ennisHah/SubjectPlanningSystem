package Data

import scala.util.Try

case class Percentage(val value: Double)
case class ExamPeriod(year: Int, month: Int)

case class ModuleDesc(name: String, code: String) {
  override def equals(obj: Any): Boolean = {
    if (obj.isInstanceOf[ModuleDesc] )
      obj.asInstanceOf[ModuleDesc].code.replaceAll("\\s", "").toLowerCase() == code.replaceAll("\\s", "").toLowerCase()
    else
      false
  }
  override def hashCode(): Int = {
    code.replaceAll("\\s", "").toLowerCase().hashCode()
  }
  def year: Int = {
    var count = 0

    val code1 = code.replaceAll("\\s", "")
    while(Try(code1.charAt(count).toString.toInt).isFailure && count < 20) {
      count += 1
    }
    if (count < 20)
      code1.charAt(count).toString.toInt
    else
      1
  }
}


case class Module(description: ModuleDesc, period: ExamPeriod, courseworkPercentage: Option[Double], examPercentage: Option[Double], overallPercentage: Option[Double], grade: String, status: String){

  def year: Int = {
    var count = 0

    val code = description.code.replaceAll("\\s", "")
    while(Try(code.charAt(count).toString.toInt).isFailure && count < 20) {
      count += 1
    }
    if (count < 20)
      code.charAt(count).toString.toInt
    else
      1
  }
  def isPass: Boolean = {
    grade match {
      case "A^" => true
      case "A+^" => true
      case "A-^" => true
      case "A+" => true
      case "A-" => true
      case "A" => true
      case "B^" => true
      case "B+^" => true
      case "B-^" => true
      case "B" => true
      case "B+" => true
      case "B-" => true
      case "C" => true
      case "C+" => true
      case "C-" => true
      case "C^" => true
      case "C+^" => true
      case "C-^" => true
      case "D" => true
      case "D^" => true
      case "D*" => true
      case "D**" => true
      case "P" => true
      case "P*"=> true
      case "EX"=> true
      case "-" => true
      case "AU" => true
      case _ => false
    }
  }

  def isFail: Boolean = {
    grade match {
      case "F#^" => true
      case "F*" => true
      case "F" => true
      case _ => false
    }
  }
  def isFirst: Boolean = {
    status == "" || status == " "
  }
  def isFirstPass: Boolean = {
    grade match {
      case "A" => true
      case "A+" => true
      case "A-" => true
      case "B" => true
      case "B+" => true
      case "B-" => true
      case "C" => true
      case "C+" => true
      case "C-" => true
      case "D" => true
      case "D*" => false
      case "D**" => false
      case "P" => true
      case "P*"=> false
      case "EX"=> false
      case _ => false
    }
  }
  def isResitPass: Boolean = {
    grade match {
      case "A" => true
      case "A+" => true
      case "A-" => true
      case "B" => true
      case "B+" => true
      case "B-" => true
      case "C" => true
      case "C+" => true
      case "C-" => true
      case "C*" => true
      case "D" => false
      case "D*" => true
      case "D*^" => true
      case "D**" => true
      case "D**^" => true
      case "P" => false
      case "P*"=> false
      case "EX"=> false
      case _ => false
    }
  }
  def isExempted: Boolean = {
    grade match {
      case "EX"=> true
      case _ => false
    }
  }
  def isTransfer: Boolean = {
    grade match {
      case "A+^" => true
      case "A^" => true
      case "A-^" => true
      case "B+^" => true
      case "B^" => true
      case "B-^" => true
      case "C+^" => true
      case "C^" => true
      case "C-^" => true
      case "D^" => true
      case "F^" => true
      case "F#^" => true
      case _=> false
    }
  }
}

object Module {
  implicit class GradePointAverage(x: Double) {
    def toYearOneAverage: Double = x / 4.0 * 100
    def toGPA: Double = x / 100 * 4.00
  }

}

/**
  * Model class of student
  *
  * @param id
  * @param yearOneAverage
  * @param overallAverage CGPA of student start to calculate from second year
  * @param qualification
  * @param cohort
  * @param own
  * @param foreign
  * @param country
  * @param gender
  * @param name
  */
case class Student(val id: Int, val yearOneAverage: Percentage, val overallAverage: Option[Percentage], val qualification: Iterable[(String, String, String)], val cohort: String, val own: Boolean, val foreign: Boolean, val country: String,
                   val gender: String, val name: String, val isDiploma: Boolean, val isBachelor: Boolean, val isDirectEntry: Boolean) {
  val DPattern = "DIPLOMA".r
  val BPattern = "BACHELOR".r

  def highestQualification: String = {
    var high = ""
    var found = false
    for (q <- qualification){
      if (isBachelor && !found) {
        high = q._1
        found = true
      }  else if(isDiploma && !found){
        high = q._1
        found = true
      } else if(!found){
        high = q._1
      } else{

      }

    }
    high
  }

  def highestQualificationData: String = {
    var high = ""
    var data = ""
    var found = false
    for (q <- qualification){
      if (isBachelor && !found) {
        high = q._1
        data = q._2 + ", " + q._3
        found = true
      }  else if(isDiploma && !found){
        high = q._1
        data = q._2 + ", " + q._3
        found = true
      } else if(!found){
        high = q._1
        data = q._2 + ", " + q._3
      } else{

      }
    }
    data
  }

}


trait StudentResult { student: Student =>
  import scala.math._
  import breeze.stats._
  val result: Iterable[Module]

  def modules(minyear: Option[Int], month: Option[Int], code: Option[String], description: Option[String]): Seq[Module] = {
    var modulesTemp: Seq[Module] = Seq[Module]()
    minyear match {
      case Some(x) =>
        modulesTemp = student.result.filter(m => m.period.year == x ).toSeq
      case None =>
        modulesTemp = student.result.toSeq

    }
    month match {
      case Some(x) =>
        modulesTemp = modulesTemp.filter(m => m.period.month == x).toSeq
      case None =>
        modulesTemp = modulesTemp
    }
    code match {
      case Some(x)=>
        modulesTemp = modulesTemp.filter(m => m.description.code == x && m.description.name == description.get).toSeq
      case None =>
        modulesTemp = modulesTemp
    }
    modulesTemp
  }

  def firstPassMean(year: Option[Int], month: Option[Int]): Double = {
    var modules: Iterable[Module] = List[Module]()
    year match {
      case Some(x) =>
        modules = student.result.filter(m => m.period.year == x && m.status == "" && m.isFirstPass).toList
        mean(modules.filter(_.overallPercentage.isDefined).map(_.overallPercentage.get).toSeq)
      case None =>
        modules = student.result.toList
        mean(modules.filter(_.overallPercentage.isDefined).map(_.overallPercentage.get).toSeq)
    }
    month match {
      case Some(x) =>
        modules = modules.filter(m => m.period.month == x && m.status == "" && m.isFirstPass).toList
        mean(modules.filter(_.overallPercentage.isDefined).map(_.overallPercentage.get).toSeq)
      case None =>
        modules = modules
        mean(modules.filter(_.overallPercentage.isDefined).map(_.overallPercentage.get).toSeq)
    }

    //!modules.exists(x=> !x.isPass)
  }
  def averageMean(year: Option[Int], month: Option[Int]): Double = {
    var modules: Iterable[Module] = List[Module]()

    year match {
      case Some(x) =>
        modules = student.result.filter(m => m.period.year == x).toList.filter(m => !m.isExempted)
        mean(modules.filter(_.overallPercentage.isDefined).map(_.overallPercentage.get).toSeq)
      case None =>
        modules = student.result.toList.filter(m => !m.isExempted)
        mean(modules.filter(_.overallPercentage.isDefined).map(_.overallPercentage.get).toSeq)
    }
    month match {
      case Some(x) =>
        modules = modules.filter(m => m.period.month == x).toList
        mean(modules.filter(_.overallPercentage.isDefined).map(_.overallPercentage.get).toSeq)
      case None =>
        modules = modules
        mean(modules.filter(_.overallPercentage.isDefined).map(_.overallPercentage.get).toSeq)
    }

    //!modules.exists(x=> !x.isPass)
  }
  def averageMean(year: Option[Int], month: Option[Int], myear: Int): Option[Double] = {
    var modules: Iterable[Module] = List[Module]()
    year match {
      case Some(x) =>
        modules = student.result.filter(m => m.period.year == x && m.year == myear).toList.filter(m => !m.isExempted)
        if (modules.size == 0){
          None
        } else {
          Some(mean(modules.filter(_.overallPercentage.isDefined).map(_.overallPercentage.get).toSeq))
        }
      case None =>
        modules = student.result.toList.filter( m => !m.isExempted && m.year == myear)

        if (modules.size == 0){
          None
        } else {
          Some(mean(modules.filter(_.overallPercentage.isDefined).map(_.overallPercentage.get).toSeq))
        }
    }
    month match {
      case Some(x) =>
        modules = modules.filter(m => m.period.month == x).toList
        if (modules.size == 0){
          None
        } else {
          Some(mean(modules.filter(_.overallPercentage.isDefined).map(_.overallPercentage.get).toSeq))
        }
      case None =>
        modules = modules
        if (modules.size == 0){
          None
        } else {
          Some(mean(modules.filter(_.overallPercentage.isDefined).map(_.overallPercentage.get).toSeq))
        }
    }

    //!modules.exists(x=> !x.isPass)
  }

  def passAllSubject(year: Option[Int], month: Option[Int]): Option[Boolean] = {
    var modules: Iterable[Module] = List[Module]()
    year match {
      case Some(x) =>
        modules = student.result.filter(m => m.period.year == x).toList
      case None =>
        modules = student.result.toList
    }
    month match {
      case Some(x) =>
        modules = modules.filter(m => m.period.month == x).toList
      case None =>
        modules = modules
    }
    var found = true
    for ( m <- modules){
      if (!m.isPass){
        found = false
      }
    }
    if (modules.size == 0){
      None
    } else {
      Some(found)
    }
    //!modules.exists(x=> !x.isPass)
  }

  def inSemester(year: Option[Int], month: Option[Int]): Boolean = {
    var result = false
    year match {
      case Some(x) =>
        month match {
          case Some(y)=>
            result = student.result.exists(m => m.period.year == x && m.period.month == y)
          case None =>
            result = student.result.exists(m => m.period.year == x)
        }

      case None =>
        month match {
          case Some(y)=>
            result = student.result.exists(m => m.period.month == y)
          case None =>
            result = false
        }
    }
    result
  }
}


case class StudentStatus(id: String, cohort: String, sem: Int, name: String, status: String, graduated: String, classfication: String, cavg: Double, year: Int, country: String) {
  def isFinish: Boolean = {
    if (status == "Finished") {
      return true
    } else {
      false
    }
  }
  def isActive: Boolean = {
    if (status == "Finished" || status == "Active") {
      return true
    } else {
      false
    }
  }
  def isLeave: Boolean = {
    if ((status.contains("Withdraw") || status.contains("Transfer Out")) || status.contains("Excluded")) {
      return true
    } else {
      false
    }
  }
  def isTransfer: Boolean = {
    if (status.contains("Transfer Out")) {
      return true
    } else {
      false
    }
  }
  def isDefer: Boolean = {
    if (status.contains("Defer")) {
      return true
    } else {
      false
    }
  }
  def isWithDraw: Boolean = {
    if (status.contains("Withdraw")) {
      return true
    } else {
      false
    }
  }
  def isCompleted: Boolean = {
    if (status.contains("Completed")) {
      return true
    } else {
      false
    }
  }
  def isNotEnrol: Boolean = {
    if (status.contains("Not Enrol")) {
      return true
    } else {
      false
    }
  }
  def isGraduated: Boolean = {
    if (graduated.contains("Y") ) {
      return true
    } else {
      false
    }
  }
  def isExitProgram: Boolean = {
    if (status.contains("Excluded")) {
      return true
    } else {
      false
    }
  }

  def isOther: Boolean = {
    val list = List("Completed", "Withdraw", "Defer", "Transfer Out", "Finished" , "Excluded", "Not Enrol")
    if (list.contains(status)){
      false
    } else {
      true
    }
  }
  def isAttrition: Boolean = {
    val list = List("Withdraw", "Defer", "Transfer Out", "Excluded")
    if (list.contains(status)){
      false
    } else {
      true
    }
  }
}

case class StudentQualificationData( qualifications: Iterable[(String, String, String)], school: String, country: String, gender: String, race: String, ic: String)
